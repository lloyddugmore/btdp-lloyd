# Terraform Example Component 1

A Terraform component consisting of just a simple S3 bucket.

This component uses [terraform-core](https://github.com/waybeyond-io/terraform-core). The terraform-core README has a brief overview about using Terraform.

There's also [Terraform Example Component 2](https://github.com/waybeyond-io/terraform-example-component-2), which depends on this component, and shows using a deployment artifact (a lambda zip).

# Table of Contents

- [TLDR;](#tldr)
- [Repo orientation](#repo-orientation)
- [Deploying](#deploying)
    - [Deploying via Buildkite](#deploying-via-buildkite)
    - [Deployment from local machine](#deployment-from-local-machine)
- [Troubleshooting](#troubleshooting)

# TLDR;

- Read [the TLDR in terraform-core](https://github.com/waybeyond-io/terraform-core#tldr).
- Copy, paste and edit this repo for your own purposes.
- You __must__ change the `.component_name` [[explanation](https://github.com/waybeyond-io/terraform-core#component_name)]
- Start writing all your shiny new terraform in the `infra/` folder.
   + Probably all you need to touch in `infra/config.tf` is the custom [inputs](./infra/config.tfL35), [outputs](./infra/config.tf#L67) and any [internal vars](./infra/config.tf#L49) you want.
   + You need to set values for your custom inputs in an `infra/<env>.tfvars` file for each environment namespace you wish to deploy to (not to be confused with an AWS account) [[explanation](https://github.com/waybeyond-io/terraform-core#1-environment-name)].
- Add your new component to Buildkite [[how-to](#adding-the-pipeline-to-buildkite)].

The rest of the docs here and in [terraform-core](https://github.com/waybeyond-io/terraform-core) can be treated as a reference when you have trouble or would like to understand something more deeply.

# Repo orientation

## [.component_name](./.component_name) file

Contains the globally unique, canonical name of this component.

## [infra/](./infra) folder

Contains all the Terraform infrastructure-as-code.

### [infra/config.tf](./infra/config.tf) file

Has the configuration for Terraform itself, and declares the inputs and outputs for this component's infrastructure.

### `<environment>.tfvars` files

These set the environment-specific input values.

### `infra/.terraform` and `infra/.plans`

These files are generated by terraform. They are .gitignored and should not be touched humans.


## [.buildkite/](./buildkite) folder

The buildkite pipelines definitions.

## [.editorconfig](./.editorconfig) and [.gitattributes](./.gitattributes) 

It's worth mentioning that these are extra important for repo's using Buildkite, because if you make shell scripts for your pipeline, they will break unless they use linux line endings (`\n`). These files will get your IDE and git to comply with this.

# Deploying

Buildkite is the go-to, easiest way to deploy this. You'll no doubt find this example is already setup in Buildkite, but if you have copy and pasted this for your own purposes, you'll need to add your component to Buildkite.

Deploying locally can be useful when you're rapidly iterating terraform code (the plan step will tell you about bugs in your terraform), trouble-shooting a terraform deploy, or tearing down a temporary environment. 

## Deploying via Buildkite

To do things in Buildkite, you'll need to log into Buildkite with your github account. If this is your first time logging in, someone with Buildkite admin will have to add you to the developer team, so you can see the pipelines.

### Adding the pipeline to Buildkite

- Create a new pipeline with the following fields:
    + Name - `your-repo-name deploy`
    + Git Repository - choose our org from the dropdown and find and select your repo. If it doesn't show up for some reason, just paste in the ssh clone URL.
    + Uncheck "Auto-create webhooks".  
      _Running when code is pushed and updating build statuses is more suited for pipelines which build/test code._
    + Steps
        * In the "Add" dropdown, choose "Read steps from repository"
        * Commands to run - `~/buildkite-env-steps/pipeline.deploy.sh | buildkite-agent pipeline upload`
          * Note, it's possible to specify an alternative pipeline yaml file here, by passing the file path (relative to the repo root) as a parameter after `pipeline.deploy.sh` and before the pipe. 
- Hit "Create Pipeline" and skip the screen talking about webhooks.

### Running the pipeline in Buildkite

1. Hit "New Build"
   1. Message _[optional]_ - Your reason for deploying. If left blank, it will use the latest git commit message.
   0. Commit / Branch _[optional]_ - if you're deploying a different branch or old commit for some reason.
   0. Hit "Create Build".
0. The pipeline will prompt you to select:
   1. Queue / AWS account - __[important]__ - The Buildkite agent queues exist in different AWS accounts, and the queue you choose will determine which AWS account you're deploying into. It's critical to get this right, because you don't want to be, for example, trying to deploy into a non-existent `dev` environment namespace on the production AWS account. That said, it does provide sensible defaults for important branches like dev.
   0. Environment Namespace - The naming prefix you want to see on the resources you're about to deploy. The same environment will be used by default to satisfy infrastructure dependencies if your component uses outputs of other components. Again, this provides sensible defaults for important branches.
0. When the terraform plan step has finished, review the plan to ensure it's going to do what you expect.
0. Unblock the Deploy step.

### Detailed explanation of the pipeline steps

The steps are defined in [.buildkite/pipeline.deploy.yml](./.buildkite/pipeline.deploy.yml)

#### A Note on QUEUE and ENVIRONMENT

The custom "Commands to run" used for the pipeline setup, will cause some dynamic steps to run at the start of your pipeline. They will enable the QUEUE (AWS Account) and ENVIRONMENT vars to be set interactively. It will also cause Buildkite to load `.buildkite/pipeline.deploy.yml` instead of the default `.buildkite/pipeline.yml`.

You can find more detail and review the actual code for the dynamic steps [here](https://github.com/waybeyond-io/terraform-core/tree/main/deploy-agent-envs/buildkite-env-steps).

#### 1) Plan

Runs:

```bash
~/tf/init.sh
~/tf/plan.sh
```
These scripts are already present on the build agents. You can find more detail and review the actual code for these scripts [here](https://github.com/waybeyond-io/terraform-core/tree/main/tf).

```yml
    agents:
      queue: ${QUEUE}
```

Determines the buildkite agent queue (and therefore AWS account) you're deploying in. It's critical to have this on all steps which use terraform commands. The value for QUEUE will be set by the interactive steps which run before the steps defined in this repo.

```yml
    env:
      TERRAFORM_VERSION: "1.3.7"
```

Specifies the exact version of terraform you'd like to run. If it's not on the buildkite agent yet, the agent will attempt to install it automatically for you.

#### 2) Wait / Block / Review

The wait step means the following steps are unavailable until the previous step is completed. We shouldn't be proceeding past this point until plan is done, and we have reviewed the planned infrastructure changes (which can be viewed in the logs of the Plan step).

When you're happy with the plan, manually unblock the block step.

#### 2) Deploy

Note that because agents run in an autoscaling group, it's common on CICD systems for later steps to occur on different agent machines to the previous steps (each step is like a different job on a queue, which any worker can perform). For this reason we need to Init again, and the plan and apply scripts take care of uploading the plan in the previous step to a special, encrypted bucket, and downloading it for this step, so we're not relying on the plan file remaining present on local disk between steps.

```bash
~/tf/init.sh
~/tf/apply.sh
```

## Deployment from local machine

- This assumes you've followed [the TLDR in terraform-core](https://github.com/waybeyond-io/terraform-core#tldr) to setup your local machine.

- Work on your commandline from the directory where `.component_name` is located.
  
_Note that if you want to, you can inspect the code for the scripts used [here](https://github.com/waybeyond-io/terraform-core/tree/main/deploy-agent-envs) and [here](https://github.com/waybeyond-io/terraform-core/tree/main/tf). They will already be on your machine if you've followed the terraform-core TLDR steps._

### Deployment steps

#### 1) Target the desired AWS Account and Environment Namespace

Authenticate with your target AWS account, using a role which has permissions to create and modify infrastructure, then:

```bash
# Target the desired AWS account - sets all the terraform-core required env vars, etc
source ~/tf-dev-account.sh
# Target the desired environment namespace
export ENVIRONMENT=dev
```

#### 2) Initialize terraform

```bash
~/tf/init.sh
```
You don't have to run init every time you plan or apply, __but you do have to do it each time you target a new AWS account and/or environment, in other words, each time you redo `source ~/tf-<acc>-account.sh` or change the `ENVIRONMENT` var, you MUST re-run `~/tf/init.sh`, otherwise you can enjoy some undefined behaviour.__

Init downloads the Terraform plugins specified in [config.tf](infra/config.tf) and configures the terraform state backend to use terraform-core for state files, for locking the pipeline, etc. As a result, you'll stay in-sync with the same infrastructure state tracking used when deploying via Buildkite pipelines. It also applies the targets set in Step 1. 

#### 3) Plan

```bash
~/tf/plan.sh
```

#### 3.5) Review

Carefully review the outputted infrastructure change plan, to ensure it's exactly what you're expecting. Peer review is a good idea here.

#### 4) Deploy

```bash
~/tf/apply.sh
```

That's it. Your infrastructure changes will be rolled out. If you run into trouble, see [troubleshooting](#troubleshooting).

#### Review outputs

If you want to review the values for the custom outputs you defined in your terraform for a given deployment:

1. Do steps 1 & 2 from Deployment steps above if you haven't already.
0. `~/tf/outputs.sh`

#### Teardown

You probably don't want to do this on a shared environment like dev, but you might want to do it if you've deployed to your own temporary environment.

If you wish to destroy all infrastructure defined in your Terraform code in the currently targted AWS account and environment:

1. Do steps 1 & 2 from Deployment steps above if you haven't already.  
   _Take care that you're targeting the correct AWS account and environment._
0. `~/tf/destroy.sh`

# Troubleshooting

- [It says the state is locked when I try to plan/apply/etc.](#it-says-the-state-is-locked-when-i-try-to-planapplyetc)
- [Error after accidentally initing with the wrong AWS account](#error-after-accidentally-initing-with-the-wrong-aws-account)
- [My state file is messed up](#my-state-file-is-messed-up)

## It says the state is locked when I try to plan/apply/etc.

You get this error output from the command:

```yaml
│ Error: Error acquiring the state lock
│
│ Error message: ConditionalCheckFailedException: The conditional request failed
│ Lock Info:
│   ID:        8316f61c-452e-828a-c178-aa5799f41af9
│   Path:      dev-terraformcore-state/environment=dev/component=example1/dev_example1_terraform.tfstate
│   Operation: OperationTypePlan
│   Who:       AG-JMORRIS\Jordan Morris@AG-JMorris
│   Version:   1.3.1
│   Created:   2022-10-06 21:48:30.1784513 +0000 UTC
```

Firstly, it may be that someone (or a CICD pipeline) is already doing something with this component. Consider checking or waiting and trying again later. You might need to pull changes if someone else has deployed. A clue for this is the `Who` value from the error output. It's yourself, it's probably safe to unlock it.

If you think the component is locked incorrectly, e.g. you interrupted a terraform command and the lock wasn't released, you can run this command:

```bash
~/tf/unlock.sh <LockId>
```

`<LockId>` comes from the `ID` values in the error output.

If you have trouble with this approach, or the error message doesn't display a lock ID, you can find the record in the dynamo-db lock table for your target AWS account, e.g. `dev-terraformcore-remote-state-locking`, and delete the record corresponding to your deployment, e.g. `dev-terraformcore-state/environment=dev/component=example1/dev_example1_terraform.tfstate-md5`.

## Error after accidentally initing with the wrong AWS account  

You may get a repeated error after running init after accidentally initing when authed with the wrong AWS account

If you init and get an error, then realise you were authed with the wrong AWS account (mismatched with to the environment variables you're using), but then you auth with the correct account and re-init, sometimes you still get an error. 

The solution is to just run init a third time, and it should sort itself out and work.

## My state file is messed up

### Restore the state file

The S3 bucket with state files is versioned, so you can get previous versions of state files if that helps. You do have to be careful of this, because it may be out-of-sync with reality since it's old. See [Out-of-sync](#out-of-sync).

### Out-of-sync

Getting in this situation is rare, and when it happens, fixing it is tricky Approach with care and plenty of peer review for each step you take.

#### Infrastructure drift

If someone changes some infrastructure which is managed by Terraform, it makes the live infrastructure out-of-sync with what Terraform has recorded in the state (this is knows as "infrastructure drift"). Generally, the infrastructure should only be changed via your Terraform code, but accidents and emergencies happen.

When you run plan, Terraform will detect drift in infrastructure, and will show in the plan that it intends to revert the changes back to what's in your code. If you want to keep things as per the live infrastructure, simply change your terraform code to reflect the reality of the infrastructure, and run plan apply again to update the state.

#### Terraform wants to create infrastructure which already exists

If there's infrastructure defined in your Terraform code, and it already exists in the live infrastructure, but for some reason isn't tracked by your current state file, then the Terraform plan will show that it intends to create it. This won't work if you try, because it will conflict with the existing infrastructure. This may happen if you have lost the most outdated state file.

This may also happen if you rename a resource declaration, since the resource declaration names are what Terraform uses to track them. In this case, the plan may show it will tear down the previous infrastructure item and re-created it under the new name. This may cause a conflict with the aws resource name, and you may have reasons not to tear down the resource. Generally it's advisable not to rename resource declarations after they're deployed, but the following can work around this.

To fix this, you can [import](https://www.terraform.io/cli/import/usage) the existing infrastructure, to adopt it into the Terraform state.

Import needs the same var parameters as the plan command, plus the `resource_type.resource` and the `ID` of the live resource. What the "ID" of the live resource means depends on the type of infrastructure. Just Google something like `terraform import bucket` to figure out what you should use for the ID.

Example of adopting an S3 bucket named `dev-example1-testfiles`:

First, init Terraform (see deploying locally steps), then:

```bash
# !!! Use with care. Never track the same live infrastructure from two different state files !!!
terraform -chdir=infra/ import \
  -var-file="${ENVIRONMENT}.tfvars" \
  -var="commit_id=$(git log -1 --format='%H')" \
  -var="terraform_core_region=${TERRAFORM_CORE_REGION}" \
  -var="terraform_state_bucket_name=${TERRAFORM_STATE_BUCKET_NAME}" \
  -var="waybeyond_build_artifacts_bucket_name=${WAYBEYOND_BUILD_ARTIFACTS_BUCKET_NAME}" \
  -var="component=$(cat .component_name | tr -d '[:space:]')" \
  aws_s3_bucket.testfiles "dev-example1-testfiles"
```

## Error in Buildkite pipeline about Permission denied on my shell script

Example error:

```bash
/bin/bash: line 1: deploy/upload-global-artifact.sh: Permission denied
```

You need to set the executable flag on your script. You can do this with git, e.g.:

```bash
git update-index --chmod=+x deploy/upload-global-artifact.sh
```
